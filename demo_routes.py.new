from flask import render_template, request, redirect, url_for, flash, abort, send_file, jsonify, make_response
import time as time_module  # Rename to avoid conflicts
from datetime import datetime, date, time, timedelta
from sqlalchemy import func
from app import app, db
from db_utils import safe_db_operation, fresh_session_operation
from models import (
    Patient, Condition, Vital, MedicalDocument, 
    LabResult, ImagingStudy, ConsultReport, HospitalSummary, 
    Screening, Appointment, DocumentType
)

# Define a context processor for global template functions
@app.context_processor
def utility_processor():
    def get_all_patients():
        from models import Patient
        import logging
        
        try:
            # Ensure any previous transaction issues are cleared
            db.session.rollback()
            # Get patients with fresh connection
            return Patient.query.order_by(Patient.last_name, Patient.first_name).all()
        except Exception as e:
            # Log error and return empty list instead of crashing
            logging.error(f"Error fetching patients in utility_processor: {str(e)}")
            return []
    
    return {
        'get_all_patients': get_all_patients
    }

# Add a datetime filter for templates
@app.template_filter('datetime')
def format_datetime(value, format='%B %d, %Y'):
    """Format a datetime object to a readable string."""
    if value is None:
        return ""
    return value.strftime(format)
from forms import (PatientForm, ConditionForm, VitalForm, 
                  VisitForm, LabResultForm, ImagingStudyForm, ConsultReportForm, 
                  HospitalSummaryForm, ScreeningForm, CSVUploadForm, DocumentUploadForm,
                  AppointmentForm)
from models import (Patient, Condition, Vital, Visit, LabResult, ImagingStudy, 
                   ConsultReport, HospitalSummary, Screening, MedicalDocument, DocumentType,
                   Appointment)
from utils import (process_csv_upload, generate_prep_sheet, evaluate_screening_needs,
                  process_document_upload, get_patient_documents_summary, extract_document_text_from_url,
                  group_documents_by_type)

# API endpoint to get available time slots for a specific date
@app.route('/get-available-slots')
@fresh_session_operation
def get_available_slots():
    """API endpoint to get available appointment time slots for a specific date"""
    # Get the date from the request
    date_str = request.args.get('date')
    if not date_str:
        return jsonify({'success': False, 'message': 'Date is required'})
    
    # Parse the date from string
    try:
        # Handle both ISO format and alternative formats
        if '-' in date_str:
            # ISO format: 2025-05-06
            date_obj = datetime.strptime(date_str, '%Y-%m-%d').date()
        elif '/' in date_str:
            # Alternative format: MM/DD/YYYY
            date_obj = datetime.strptime(date_str, '%m/%d/%Y').date()
        else:
            return jsonify({'success': False, 'message': 'Invalid date format'})
    except ValueError:
        return jsonify({'success': False, 'message': 'Invalid date'})
    
    # Get appointment ID if editing an existing appointment
    appointment_id = request.args.get('appointment_id')
    if appointment_id and appointment_id.isdigit():
        appointment_id = int(appointment_id)
    else:
        appointment_id = None
    
    # Get available and booked time slots
    from appointment_utils import get_available_time_slots, get_booked_time_slots
    
    available_slots = get_available_time_slots(date_obj, appointment_id)
    booked_slots = get_booked_time_slots(date_obj, appointment_id, as_string=True)
    
    # Format available slots for display in dropdown
    formatted_slots = []
    for slot in available_slots:
        hour, minute = map(int, slot.split(':'))
        if hour < 12:
            label = f"{hour or 12}:{minute:02d} AM"
        elif hour == 12:
            label = f"12:{minute:02d} PM"
        else:
            label = f"{hour-12}:{minute:02d} PM"
        
        formatted_slots.append({
            'value': slot,
            'label': label
        })
    
    return jsonify({
        'success': True,
        'available_slots': formatted_slots,
        'booked_slots': booked_slots
    })    # Check for date from query parameter (date picker)
    selected_date_param = request.args.get('date_str')
    
    # The refresh parameter is used as a cache-busting mechanism
    # Note its presence for debugging purposes
    refresh_param = request.args.get('refresh')
    if refresh_param:
        print(f"Cache-busting refresh param: {refresh_param}")
    
    print(f"URL date_str parameter: {date_str}")
    print(f"Query param date_str: {selected_date_param}")
    
    # Give priority to the date_str in query params, then URL param, then default to today
    if selected_date_param:
        try:
            print(f"Using date from query param: {selected_date_param}")
            selected_date = datetime.strptime(selected_date_param, '%Y-%m-%d').date()
        except ValueError:
            selected_date = today
            print(f"Invalid date in query param, using today: {today}")
            flash('Invalid date format. Showing today\'s appointments.', 'warning')
    elif date_str:
        try:
            # Parse the date string (format: YYYY-MM-DD)
            print(f"Using date from URL path: {date_str}")
            selected_date = datetime.strptime(date_str, '%Y-%m-%d').date()
        except ValueError:
            # If date is invalid, default to today
            selected_date = today
            print(f"Invalid date in URL path, using today: {today}")
            flash('Invalid date format. Showing today\'s appointments.', 'warning')
    else:
        selected_date = today
        print(f"No date specified, using today: {today}")
    
    # Get previous and next day for navigation
    prev_date = selected_date - timedelta(days=1)
    next_date = selected_date + timedelta(days=1)
    
    # Generate timestamp for cache-busting
    timestamp = int(time_module.time())
    
    # Get appointments for the selected date
    print(f"Fetching appointments for date: {selected_date}")
    print(f"Selected date type: {type(selected_date)}")
    
    try:
        from sqlalchemy import text
        # Try with an explicit SQL query to see exactly what's happening
        sql_query = text(f"SELECT * FROM appointment WHERE DATE(appointment_date) = DATE('{selected_date}')")
        print(f"Executing SQL query: {sql_query}")
        result = db.session.execute(sql_query)
        sql_appointments = [row for row in result]
        print(f"SQL query found {len(sql_appointments)} appointments")
        
        # Also try with SQLAlchemy ORM
        appointments = Appointment.query.filter(
            Appointment.appointment_date == selected_date
        ).order_by(Appointment.appointment_time).all()
        print(f"SQLAlchemy ORM query found {len(appointments)} appointments")
        
        # Also try with func.date
        from sqlalchemy import func
        func_appointments = Appointment.query.filter(
            func.date(Appointment.appointment_date) == func.date(selected_date)
        ).order_by(Appointment.appointment_time).all()
        print(f"func.date query found {len(func_appointments)} appointments")
        
        # Use the func.date query results
        appointments = func_appointments
    except Exception as e:
        print(f"Error in appointment query: {str(e)}")
        # Fallback to original query
        appointments = Appointment.query.filter(
            Appointment.appointment_date == selected_date
        ).order_by(Appointment.appointment_time).all()
    
    # Log all today's appointments for debugging
    if selected_date == today:
        print(f"Today's appointments (exact date match: {selected_date}):")
        today_appts_debug = Appointment.query.filter(
            func.date(Appointment.appointment_date) == func.date(today)
        ).all()
        print(f"Found {len(today_appts_debug)} appointments with func.date match")
        for appt in today_appts_debug:
            print(f"  ID: {appt.id}, Date: {appt.appointment_date}, Patient: {appt.patient.full_name}, Time: {appt.appointment_time}")
    print(f"Found {len(appointments)} appointments for selected date")
    
    # For debugging: show all appointments in the database
    all_appointments = Appointment.query.all()
    print(f"Total appointments in database: {len(all_appointments)}")
    for appt in all_appointments:
        print(f"Appointment ID: {appt.id}, Date: {appt.appointment_date}, Patient: {appt.patient.full_name}")
    
    return render_template('index.html', 
                          patient_count=patient_count,
                          patients=patients,
                          upcoming_visits=appointments,  # Use the appointments for the selected date for the counter
                          recent_lab_results=recent_lab_results,
                          recent_documents=recent_documents,
                          todays_appointments=appointments,
                          selected_date=selected_date,
                          prev_date=prev_date,
                          next_date=next_date,
                          today_date=today,
                          timestamp=timestamp)

@app.route('/patients')
def patient_list():
    """List all patients"""
    # Get the search query parameters
    search_query = request.args.get('search', '')
    sort_by = request.args.get('sort', 'last_name')
    order = request.args.get('order', 'asc')
    
    # Base query
    query = Patient.query
    
    # Apply search filter if provided
    if search_query:
        query = query.filter(
            db.or_(
                Patient.first_name.ilike(f'%{search_query}%'),
                Patient.last_name.ilike(f'%{search_query}%'),
                Patient.mrn.ilike(f'%{search_query}%')
            )
        )
    
    # Apply sorting
    if sort_by == 'last_name':
        if order == 'asc':
            query = query.order_by(Patient.last_name.asc())
        else:
            query = query.order_by(Patient.last_name.desc())
    elif sort_by == 'first_name':
        if order == 'asc':
            query = query.order_by(Patient.first_name.asc())
        else:
            query = query.order_by(Patient.first_name.desc())
    elif sort_by == 'dob':
        if order == 'asc':
            query = query.order_by(Patient.date_of_birth.asc())
        else:
            query = query.order_by(Patient.date_of_birth.desc())
    elif sort_by == 'mrn':
        if order == 'asc':
            query = query.order_by(Patient.mrn.asc())
        else:
            query = query.order_by(Patient.mrn.desc())
    
    # Execute the query
    patients = query.all()
    
    return render_template('patient_list.html', patients=patients, search_query=search_query)

@app.route('/patients/add', methods=['GET', 'POST'])
def add_patient():
    """Add a new patient"""
    form = PatientForm()
    if form.validate_on_submit():
        # Check if MRN already exists
        existing_patient = Patient.query.filter_by(mrn=form.mrn.data).first()
        if existing_patient:
            flash('A patient with this Medical Record Number already exists.', 'danger')
            return render_template('patient_form.html', form=form, title='Add Patient')
        
        # Create new patient
        patient = Patient(
            first_name=form.first_name.data,
            last_name=form.last_name.data,
            date_of_birth=form.date_of_birth.data,
            sex=form.sex.data,
            mrn=form.mrn.data,
            phone=form.phone.data,
            email=form.email.data,
            address=form.address.data,
            insurance=form.insurance.data
        )
        
        db.session.add(patient)
        db.session.commit()
        
        # Evaluate screening needs for the new patient
        evaluate_screening_needs(patient)
        
        flash('Patient added successfully.', 'success')
        return redirect(url_for('patient_detail', patient_id=patient.id))
    
    return render_template('patient_form.html', form=form, title='Add Patient')

@app.route('/patients/<int:patient_id>')
def patient_detail(patient_id):
    """Display patient details"""
    patient = Patient.query.get_or_404(patient_id)
    
    # Get the most recent vital signs
    recent_vitals = Vital.query.filter_by(patient_id=patient_id).order_by(Vital.date.desc()).first()
    
    # Get all vital signs for history
    all_vitals = Vital.query.filter_by(patient_id=patient_id).order_by(Vital.date.desc()).all()
    
    # Get the most recent lab results
    recent_labs = LabResult.query.filter_by(patient_id=patient_id).order_by(LabResult.test_date.desc()).limit(5).all()
    
    # Get the active conditions
    active_conditions = Condition.query.filter_by(patient_id=patient_id, is_active=True).all()
    
    # Get past visits
    past_visits = Visit.query.filter_by(patient_id=patient_id).order_by(Visit.visit_date.desc()).all()
    
    # Get screening recommendations
    screenings = Screening.query.filter_by(patient_id=patient_id).order_by(Screening.due_date).all()
    
    # Get upcoming visit if any
    upcoming_visit = Visit.query.filter(
        Visit.patient_id == patient_id,
        Visit.visit_date > datetime.now()
    ).order_by(Visit.visit_date).first()
    
    # Get patient documents
    documents = MedicalDocument.query.filter_by(patient_id=patient_id).order_by(MedicalDocument.document_date.desc()).all()
    
    # Organize documents by type
    lab_documents = [doc for doc in documents if doc.document_type == DocumentType.LAB_REPORT.value]
    imaging_documents = [doc for doc in documents if doc.document_type == DocumentType.RADIOLOGY_REPORT.value]
    consult_documents = [doc for doc in documents if doc.document_type == DocumentType.CONSULTATION.value]
    hospital_documents = [doc for doc in documents if doc.document_type == DocumentType.DISCHARGE_SUMMARY.value]
    
    # Helper function for templates to access current date
    def now():
        return datetime.now()
    
    return render_template('patient_detail.html', 
                          patient=patient,
                          recent_vitals=recent_vitals,
                          all_vitals=all_vitals,
                          recent_labs=recent_labs,
                          active_conditions=active_conditions,
                          past_visits=past_visits,
                          screenings=screenings,
                          upcoming_visit=upcoming_visit,
                          documents=documents,
                          lab_documents=lab_documents,
                          imaging_documents=imaging_documents,
                          consult_documents=consult_documents,
                          hospital_documents=hospital_documents,
                          now=now)

@app.route('/patients/<int:patient_id>/edit', methods=['GET', 'POST'])
def edit_patient(patient_id):
    """Edit patient information"""
    patient = Patient.query.get_or_404(patient_id)
    form = PatientForm(obj=patient)
    
    if form.validate_on_submit():
        # Check if MRN is being changed and already exists
        if form.mrn.data != patient.mrn and Patient.query.filter_by(mrn=form.mrn.data).first():
            flash('A patient with this Medical Record Number already exists.', 'danger')
            return render_template('patient_form.html', form=form, title='Patient Demographics')
        
        # Update patient data
        form.populate_obj(patient)
        db.session.commit()
        
        # Re-evaluate screening needs
        evaluate_screening_needs(patient)
        
        flash('Patient demographics updated successfully.', 'success')
        return redirect(url_for('patient_detail', patient_id=patient.id))
    
    return render_template('patient_form.html', form=form, title='Patient Demographics', patient=patient)

@app.route('/patients/<int:patient_id>/prep_sheet')
def generate_patient_prep_sheet(patient_id):
    """Generate a visit preparation sheet for the patient"""
    patient = Patient.query.get_or_404(patient_id)
    
    # Get the date of the last visit
    last_visit = Visit.query.filter_by(patient_id=patient_id).order_by(Visit.visit_date.desc()).first()
    last_visit_date = last_visit.visit_date if last_visit else None
    
    # Get data since the last visit or in the last 90 days if no previous visit
    cutoff_date = last_visit_date if last_visit_date else datetime.now() - timedelta(days=90)
    
    # Get recent data for the prep sheet
    recent_vitals = Vital.query.filter(
        Vital.patient_id == patient_id,
        Vital.date > cutoff_date
    ).order_by(Vital.date.desc()).all()
    
    recent_labs = LabResult.query.filter(
        LabResult.patient_id == patient_id,
        LabResult.test_date > cutoff_date
    ).order_by(LabResult.test_date.desc()).all()
    
    recent_imaging = ImagingStudy.query.filter(
        ImagingStudy.patient_id == patient_id,
        ImagingStudy.study_date > cutoff_date
    ).order_by(ImagingStudy.study_date.desc()).all()
    
    recent_consults = ConsultReport.query.filter(
        ConsultReport.patient_id == patient_id,
        ConsultReport.report_date > cutoff_date
    ).order_by(ConsultReport.report_date.desc()).all()
    
    recent_hospital = HospitalSummary.query.filter(
        HospitalSummary.patient_id == patient_id,
        HospitalSummary.admission_date > cutoff_date
    ).order_by(HospitalSummary.admission_date.desc()).all()
    
    active_conditions = Condition.query.filter_by(
        patient_id=patient_id, 
        is_active=True
    ).all()
    
    screenings = Screening.query.filter_by(patient_id=patient_id).all()
    
    # Generate a prep sheet summary
    prep_sheet_data = generate_prep_sheet(
        patient, 
        recent_vitals, 
        recent_labs, 
        recent_imaging, 
        recent_consults, 
        recent_hospital, 
        active_conditions, 
        screenings,
        last_visit_date
    )
    
    return render_template('prep_sheet.html', 
                          patient=patient,
                          prep_sheet=prep_sheet_data,
                          recent_vitals=recent_vitals,
                          recent_labs=recent_labs,
                          recent_imaging=recent_imaging,
                          recent_consults=recent_consults,
                          recent_hospital=recent_hospital,
                          active_conditions=active_conditions,
                          screenings=screenings,
                          last_visit_date=last_visit_date,
                          today=datetime.now())

@app.route('/patients/<int:patient_id>/condition', methods=['GET', 'POST'])
def add_condition(patient_id):
    """Add a medical condition to a patient"""
    patient = Patient.query.get_or_404(patient_id)
    form = ConditionForm()
    
    if form.validate_on_submit():
        condition = Condition(
            patient_id=patient_id,
            name=form.name.data,
            code=form.code.data,
            diagnosed_date=form.diagnosed_date.data,
            is_active=form.is_active.data,
            notes=form.notes.data
        )
        
        db.session.add(condition)
        db.session.commit()
        
        # Re-evaluate screening needs based on new condition
        evaluate_screening_needs(patient)
        
        flash('Condition added successfully.', 'success')
        return redirect(url_for('patient_detail', patient_id=patient_id))
    
    return render_template('condition_form.html', form=form, patient=patient)

@app.route('/patients/<int:patient_id>/vitals', methods=['GET', 'POST'])
def add_vitals(patient_id):
    """Add vital signs for a patient"""
    patient = Patient.query.get_or_404(patient_id)
    form = VitalForm()
    
    # Populate the height field from the last recorded vital signs
    last_vitals = Vital.query.filter_by(patient_id=patient_id).order_by(Vital.date.desc()).first()
    if last_vitals and not form.height.data and request.method == 'GET':
        # Convert from cm to inches for display
        form.height.data = last_vitals.height / 2.54  # Convert cm to inches
    
    if form.validate_on_submit():
        # Convert the form data from American units to metric for database storage
        weight_kg = form.weight.data / 2.20462 if form.weight.data else None  # Convert lbs to kg
        height_cm = form.height.data * 2.54 if form.height.data else None  # Convert inches to cm
        temperature_c = (form.temperature.data - 32) * 5/9 if form.temperature.data else None  # Convert °F to °C
        
        # Calculate BMI if weight and height are provided
        bmi = None
        if weight_kg and height_cm:
            # BMI = weight(kg) / (height(m))^2
            height_m = height_cm / 100  # convert cm to m
            bmi = round(weight_kg / (height_m * height_m), 1)
        
        vital = Vital(
            patient_id=patient_id,
            date=form.date.data,
            weight=weight_kg,
            height=height_cm,
            bmi=bmi,
            temperature=temperature_c,
            blood_pressure_systolic=form.blood_pressure_systolic.data,
            blood_pressure_diastolic=form.blood_pressure_diastolic.data,
            pulse=form.pulse.data,
            respiratory_rate=form.respiratory_rate.data,
            oxygen_saturation=form.oxygen_saturation.data
        )
        
        db.session.add(vital)
        db.session.commit()
        
        flash('Vital signs added successfully.', 'success')
        return redirect(url_for('patient_detail', patient_id=patient_id))
    
    return render_template('vitals_form.html', form=form, patient=patient)

@app.route('/patients/<int:patient_id>/documents')
def patient_documents(patient_id):
    """View a patient's documents"""
    patient = Patient.query.get_or_404(patient_id)
    
    # Get all documents for this patient
    all_documents = MedicalDocument.query.filter_by(patient_id=patient_id).order_by(MedicalDocument.document_date.desc()).all()
    
    # Group documents by type
    grouped_documents = group_documents_by_type(all_documents)
    
    # Get recent documents for the sidebar
    recent_documents = all_documents[:5] if all_documents else []
    
    # Count total documents
    document_count = len(all_documents)
    
    # Helper function for templates to access current date
    def now():
        return datetime.now()
        
    return render_template('patient_documents.html', 
                          patient=patient, 
                          documents=grouped_documents,
                          recent_documents=recent_documents,
                          document_count=document_count,
                          now=now)

@app.route('/patients/<int:patient_id>/document/add', methods=['GET', 'POST'])
def add_document(patient_id):
    """Add a document for a patient"""
    patient = Patient.query.get_or_404(patient_id)
    form = DocumentUploadForm()
    
    # Get the document type from query parameter
    doc_type = request.args.get('type')
    
    if form.validate_on_submit():
        # Process the uploaded document
        if form.file.data:
            # Get the uploaded file
            file = form.file.data
            filename = file.filename
            
            # Check if the file is an image or binary type
            mime_type = file.content_type
            is_binary = mime_type and (mime_type.startswith('image/') or not mime_type.startswith('text/'))
            
            if is_binary:
                # Store as binary for images and other binary types
                binary_content = file.read()
                content = None
                document_metadata = {"mime_type": mime_type, "filename": filename}
            else:
                # Read file content as text for text-based files
                file_content = file.read()
                try:
                    # Try to decode as UTF-8 text
                    content = file_content.decode('utf-8', errors='replace')
                    binary_content = None
                    # Process document to classify it
                    document_metadata = process_document_upload(content, filename)
                except:
                    # If decoding fails, treat as binary
                    binary_content = file_content
                    content = None
                    document_metadata = {"mime_type": mime_type or "application/octet-stream", "filename": filename}
            
            # Use the document type from query parameter if available
            document_type = DocumentType.UNKNOWN.value
            if doc_type == 'lab':
                document_type = DocumentType.LAB_REPORT.value
            elif doc_type == 'imaging':
                document_type = DocumentType.RADIOLOGY_REPORT.value
            elif doc_type == 'consult':
                document_type = DocumentType.CONSULTATION.value
            elif doc_type == 'hospital':
                document_type = DocumentType.DISCHARGE_SUMMARY.value
            else:
                # Fall back to the automatic classification for text content
                document_type = document_metadata.get('document_type', DocumentType.UNKNOWN.value)
            
            # Create new document
            document = MedicalDocument(
                patient_id=patient_id,
                filename=filename,
                document_name=form.document_name.data,
                document_type=document_type,
                content=content,
                binary_content=binary_content,
                is_binary=is_binary,
                mime_type=mime_type,
                source_system=form.source_system.data,
                document_date=form.document_date.data or datetime.now(),
                doc_metadata=json.dumps(document_metadata)
            )
            
            db.session.add(document)
            db.session.commit()
            
            flash('Document uploaded successfully.', 'success')
            
            # Redirect back to patient detail page if a specific document type was uploaded
            if doc_type in ['lab', 'imaging', 'consult', 'hospital']:
                return redirect(url_for('patient_detail', patient_id=patient_id))
            else:
                return redirect(url_for('patient_documents', patient_id=patient_id))
    
    # Set document type mapping for the template
    doc_type_map = {
        'lab': 'LAB_REPORT',
        'imaging': 'RADIOLOGY_REPORT',
        'consult': 'CONSULTATION',
        'hospital': 'DISCHARGE_SUMMARY'
    }
    doc_type_value = doc_type_map.get(doc_type, '')
    
    # Update title based on document type
    title = 'Upload Document'
    if doc_type == 'lab':
        title = 'Upload Lab Report'
    elif doc_type == 'imaging':
        title = 'Upload Imaging Study'
    elif doc_type == 'consult':
        title = 'Upload Consultation Report'
    elif doc_type == 'hospital':
        title = 'Upload Hospital Summary'
        
    return render_template('document_upload.html', 
                         form=form, 
                         patient=patient, 
                         doc_type=doc_type_value,
                         title=title)

@app.route('/documents/<int:document_id>')
def view_document(document_id):
    """View a document"""
    document = MedicalDocument.query.get_or_404(document_id)
    patient = Patient.query.get_or_404(document.patient_id)
    
    # Get metadata if available
    metadata = {}
    if document.doc_metadata:
        try:
            metadata = json.loads(document.doc_metadata)
        except:
            metadata = {}
    
    return render_template('document_view.html', 
                          document=document, 
                          patient=patient,
                          metadata=metadata)
                          
@app.route('/documents/<int:document_id>/image')
def document_image(document_id):
    """Serve a document's binary content as an image"""
    document = MedicalDocument.query.get_or_404(document_id)
    
    if not document.binary_content:
        abort(404)
    
    # Determine mime type for the response
    mime_type = document.mime_type or 'application/octet-stream'
    
    # Create a response with the binary content
    response = make_response(document.binary_content)
    response.headers.set('Content-Type', mime_type)
    return response

@app.route('/import-from-url', methods=['POST'])
def import_from_url():
    """Import document content from a URL"""
    url = request.form.get('url')
    patient_id = request.form.get('patient_id')
    
    if not url or not patient_id:
        return jsonify({'success': False, 'error': 'Missing URL or patient ID'})
    
    try:
        # Extract text from the URL
        document_text = extract_document_text_from_url(url)
        
        if not document_text:
            return jsonify({'success': False, 'error': 'Could not extract text from the provided URL'})
        
        # Process the document
        document_metadata = process_document_upload(document_text, f"Import from {url}")
        
        # Create new document
        document = MedicalDocument(
            patient_id=patient_id,
            filename=f"Import from {url}",
            document_type=document_metadata.get('document_type', DocumentType.UNKNOWN.value),
            content=document_text,
            source_system="Web Import",
            document_date=datetime.now(),
            doc_metadata=json.dumps(document_metadata)
        )
        
        db.session.add(document)
        db.session.commit()
        
        return jsonify({
            'success': True, 
            'document_id': document.id,
            'document_type': document.document_type,
            'message': 'Document imported successfully!'
        })
    except Exception as e:
        logging.error(f"Error importing from URL: {str(e)}")
        return jsonify({'success': False, 'error': str(e)})

# Error handlers
@app.errorhandler(404)
def page_not_found(e):
    return render_template('404.html'), 404

@app.route('/screenings')
def screening_list():
    """List all patients with due screenings"""
    # Get the search query parameter
    search_query = request.args.get('search', '')
    
    # Base query
    query = Screening.query.join(Patient)
    
    # Apply search filter if provided
    if search_query:
        query = query.filter(
            db.or_(
                Patient.first_name.ilike(f'%{search_query}%'),
                Patient.last_name.ilike(f'%{search_query}%'),
                Screening.screening_type.ilike(f'%{search_query}%')
            )
        )
    
    # Get screenings that are due or past due
    today = datetime.now().date()
    query = query.filter(Screening.due_date <= today + timedelta(days=60))
    
    # Order by priority (High first) and due date (earliest first)
    screenings = query.order_by(
        db.case(
            (Screening.priority == 'High', 0),
            (Screening.priority == 'Medium', 1),
            else_=2
        ),
        Screening.due_date
    ).all()
    
    return render_template('screening_list.html', 
                          screenings=screenings, 
                          search_query=search_query)

@app.errorhandler(500)
def internal_server_error(e):
    return render_template('500.html'), 500


@app.route('/debug/appointments', methods=['GET'])
def debug_appointments():
    """Debug endpoint to inspect appointments"""
    try:
        # Create an HTML response with proper formatting
        response_html = """
        <!DOCTYPE html>
        <html>
        <head>
            <title>Appointment Debugging</title>
            <link rel="stylesheet" href="https://cdn.replit.com/agent/bootstrap-agent-dark-theme.min.css">
            <style>
                body { padding: 20px; }
                pre { background-color: #f8f9fa; padding: 15px; border-radius: 5px; }
                .success { color: green; }
                .error { color: red; }
            </style>
        </head>
        <body>
            <div class="container">
                <h1>Appointments Debug Page</h1>
                <h2>Current Appointments</h2>
        """
        
        # Fetch all appointments
        all_appointments = Appointment.query.all()
        appointment_count = len(all_appointments)
        
        response_html += f"<p>Total appointments in database: <strong>{appointment_count}</strong></p>"
        
        # Get dates of appointments
        dates = {}
        for appt in all_appointments:
            date_str = appt.appointment_date.strftime('%Y-%m-%d')
            if date_str in dates:
                dates[date_str] += 1
            else:
                dates[date_str] = 1
        
        response_html += "<h3>Appointments by date:</h3><ul>"
        for date_str, count in sorted(dates.items()):
            response_html += f"<li>{date_str}: {count} appointment(s)</li>"
        response_html += "</ul>"
        
        # Get today's appointments
        today = datetime.now().date()
        today_str = today.strftime('%Y-%m-%d')
        
        response_html += f"<h3>Today's appointments ({today_str}):</h3>"
        today_appointments = Appointment.query.filter(
            Appointment.appointment_date == today
        ).order_by(Appointment.appointment_time).all()
        
        if today_appointments:
            response_html += "<table class='table table-striped'>"
            response_html += "<thead><tr><th>ID</th><th>Patient</th><th>Time</th><th>Note</th></tr></thead><tbody>"
            for appt in today_appointments:
                time_str = appt.appointment_time.strftime('%H:%M') if appt.appointment_time else "N/A"
                response_html += f"<tr><td>{appt.id}</td><td>{appt.patient.full_name}</td><td>{time_str}</td><td>{appt.note or ''}</td></tr>"
            response_html += "</tbody></table>"
        else:
            response_html += "<p>No appointments for today.</p>"
            
        # Test appointment creation section
        response_html += """
            <h2>Test Appointment Creation</h2>
            <div class="card">
                <div class="card-body">
                    <h3 class="card-title">Creating Test Appointment</h3>
        """
        
        try:
            # Create test appointment
            from datetime import time
            test_patient = Patient.query.first()
            if test_patient:
                test_appointment = Appointment(
                    patient_id=test_patient.id,
                    appointment_date=today,
                    appointment_time=time(hour=14, minute=30),
                    note="Test appointment created via debug endpoint"
                )
                db.session.add(test_appointment)
                db.session.commit()
                
                response_html += f"""
                    <div class="alert alert-success">
                        <p>Created test appointment:</p>
                        <ul>
                            <li>ID: {test_appointment.id}</li>
                            <li>Patient: {test_patient.full_name}</li>
                            <li>Date: {today_str}</li>
                            <li>Time: 14:30</li>
                        </ul>
                    </div>
                """
                
                # Verify it was created
                verify = Appointment.query.get(test_appointment.id)
                if verify:
                    response_html += f"""
                        <div class="alert alert-success">
                            Successfully verified appointment exists in database
                        </div>
                    """
                else:
                    response_html += f"""
                        <div class="alert alert-danger">
                            ERROR: Could not verify appointment in database
                        </div>
                    """
                    
                # Refresh to see the new appointment
                response_html += f"""
                    <h3>All appointments after test creation</h3>
                    <p>There should now be {appointment_count + 1} total appointments</p>
                """
                
                # Show appointments again after creation
                updated_appointments = Appointment.query.all()
                response_html += f"<p>Actual count after creation: <strong>{len(updated_appointments)}</strong></p>"
                
                # New today's appointments
                updated_today = Appointment.query.filter(
                    Appointment.appointment_date == today
                ).order_by(Appointment.appointment_time).all()
                
                response_html += f"<h4>Updated today's appointments ({today_str}):</h4>"
                if updated_today:
                    response_html += "<table class='table table-striped'>"
                    response_html += "<thead><tr><th>ID</th><th>Patient</th><th>Time</th><th>Note</th></tr></thead><tbody>"
                    for appt in updated_today:
                        time_str = appt.appointment_time.strftime('%H:%M') if appt.appointment_time else "N/A"
                        row_class = " class='table-success'" if appt.id == test_appointment.id else ""
                        response_html += f"<tr{row_class}><td>{appt.id}</td><td>{appt.patient.full_name}</td><td>{time_str}</td><td>{appt.note or ''}</td></tr>"
                    response_html += "</tbody></table>"
                else:
                    response_html += "<p>No appointments for today (this is unexpected!).</p>"
            else:
                response_html += """
                    <div class="alert alert-warning">
                        No patients available for test appointment creation
                    </div>
                """
        except Exception as e:
            response_html += f"""
                <div class="alert alert-danger">
                    Error creating test appointment: {str(e)}
                </div>
            """
            
        # Close the HTML
        response_html += """
                </div>
            </div>
            <div class="mt-4">
                <a href="/" class="btn btn-primary">Return to Home</a>
            </div>
        </div>
        </body>
        </html>
        """
        
        return response_html
    except Exception as e:
        error_html = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <title>Error</title>
            <link rel="stylesheet" href="https://cdn.replit.com/agent/bootstrap-agent-dark-theme.min.css">
        </head>
        <body>
            <div class="container mt-5">
                <div class="alert alert-danger">
                    <h3>Error occurred in debug endpoint</h3>
                    <p>{str(e)}</p>
                </div>
                <a href="/" class="btn btn-primary">Return to Home</a>
            </div>
        </body>
        </html>
        """
        return error_html


@app.route('/appointments/debug_add', methods=['GET', 'POST'])
@fresh_session_operation
def debug_add_appointment():
    """Debug version of add_appointment - simplified for testing"""
    print("=" * 50)
    print("STARTING DEBUG_ADD_APPOINTMENT...")
    
    if request.method == 'GET':
        # Just show the form
        form = AppointmentForm()
        patients = Patient.query.order_by(Patient.last_name, Patient.first_name).all()
        form.patient_id.choices = [(p.id, f"{p.full_name} (MRN: {p.mrn})") for p in patients]
        
        # Pre-populate today's date
        today = datetime.now().date()
        form.appointment_date.data = today
        
        return render_template('appointment_form.html', 
                              form=form, 
                              patients=patients, 
                              editing=False, 
                              debug_mode=True)
    
    elif request.method == 'POST':
        print(f"DEBUG POST DATA: {request.form}")
        
        # Extract form data directly
        try:
            # Get form data
            patient_id = request.form.get('patient_id')
            date_str = request.form.get('appointment_date')
            time_str = request.form.get('appointment_time')
            note = request.form.get('note', '')
            
            # Basic validation
            if not patient_id or not date_str or not time_str:
                flash('Missing required appointment data.', 'danger')
                patients = Patient.query.order_by(Patient.last_name, Patient.first_name).all()
                form = AppointmentForm(request.form)
                form.patient_id.choices = [(p.id, f"{p.full_name} (MRN: {p.mrn})") for p in patients]
                return render_template('appointment_form.html', form=form, patients=patients, editing=False, debug_mode=True)
            
            # Convert strings to appropriate data types
            appointment_date = datetime.strptime(date_str, '%Y-%m-%d').date()
            time_parts = time_str.split(':')
            hour = int(time_parts[0])
            minute = int(time_parts[1])
            from datetime import time
            appointment_time = time(hour=hour, minute=minute)
            
            # Try with SQLAlchemy
            appointment = Appointment(
                patient_id=int(patient_id),
                appointment_date=appointment_date,
                appointment_time=appointment_time,
                note=note
            )
            
            db.session.add(appointment)
            db.session.commit()
            
            # Log details
            print(f"DEBUG: Successfully created appointment with ID: {appointment.id}")
            print(f"DEBUG: Patient ID: {appointment.patient_id}")
            print(f"DEBUG: Date: {appointment.appointment_date}")
            print(f"DEBUG: Time: {appointment.appointment_time}")
            
            flash(f'DEBUG MODE: Appointment added successfully with ID {appointment.id}!', 'success')
            
            # Also check if we can query it back
            verify = Appointment.query.get(appointment.id)
            if verify:
                print(f"DEBUG: Verified appointment exists with ID: {verify.id}")
            else:
                print("DEBUG: WARNING - Could not verify appointment after creation!")
            
            # Force redirect using absolute URL
            date_str_redirect = appointment_date.strftime('%Y-%m-%d')
            return redirect('/date/' + date_str_redirect)
            
        except Exception as e:
            db.session.rollback()
            error_msg = f'DEBUG ERROR: {str(e)}'
            flash(error_msg, 'danger')
            print(error_msg)
            patients = Patient.query.order_by(Patient.last_name, Patient.first_name).all()
            form = AppointmentForm(request.form)
            form.patient_id.choices = [(p.id, f"{p.full_name} (MRN: {p.mrn})") for p in patients]
            return render_template('appointment_form.html', form=form, patients=patients, editing=False, debug_mode=True)
    
    # Should never get here
    return redirect('/')


# The simple_add_appointment function has been consolidated into the main add_appointment function

@app.route('/get-available-slots', methods=['GET'])
def get_available_slots():
    """API endpoint to get available appointment time slots for a specific date"""
    try:
        # Get the date from the query parameters
        date_str = request.args.get('date')
        if not date_str:
            return jsonify({
                'success': False,
                'message': 'Date parameter is required',
                'available_slots': [],
                'booked_slots': []
            }), 400
        
        # Parse the date
        try:
            appointment_date = datetime.strptime(date_str, '%Y-%m-%d').date()
        except ValueError:
            return jsonify({
                'success': False,
                'message': 'Invalid date format. Please use YYYY-MM-DD',
                'available_slots': [],
                'booked_slots': []
            }), 400
        
        # Get all available slots
        available_slots = get_available_time_slots(appointment_date)
        
        # Get all booked slots
        booked_slots = get_booked_time_slots(appointment_date, as_string=True)
        
        # Format available slots for the dropdown
        formatted_available_slots = []
        for slot in available_slots:
            # Convert from 24-hour to 12-hour format for display
            hour, minute = map(int, slot.split(':'))
            if hour < 12:
                label = f"{hour}:{minute:02d} AM" if hour > 0 else f"12:{minute:02d} AM"
            elif hour == 12:
                label = f"12:{minute:02d} PM"
            else:
                label = f"{hour-12}:{minute:02d} PM"
            
            formatted_available_slots.append({
                'value': slot,
                'label': label
            })
        
        return jsonify({
            'success': True,
            'available_slots': formatted_available_slots,
            'booked_slots': booked_slots
        })
    except Exception as e:
        print(f"Error getting available slots: {str(e)}")
        return jsonify({
            'success': False,
            'message': f'Error: {str(e)}',
            'available_slots': [],
            'booked_slots': []
        }), 500


@app.route('/add-appointment', methods=['GET', 'POST'], endpoint='add_appointment')
@fresh_session_operation
def add_appointment():
    """Add a new appointment - Enhanced version with 15-minute time slots and conflict prevention"""
    print("=" * 50)
    print("Starting add_appointment function...")
    print(f"Request method: {request.method}")
    print(f"Request headers: {dict(request.headers)}")
    print(f"Request is AJAX: {request.headers.get('X-Requested-With') == 'XMLHttpRequest'}")
    print(f"Request form data: {request.form}")
    print(f"Request args: {request.args}")
    print(f"Request files: {request.files}")
    print("=" * 50)
    
    # Always create a fresh form
    form = AppointmentForm()
    
    # Get pre-selected date from query parameters if available
    selected_date = request.args.get('date')
    print(f"Selected date from URL: {selected_date}")
    
    # Get the current date for debugging
    current_date = datetime.now().date()
    print(f"Current date for reference: {current_date}")
    
    # This is crucial - explicitly set appointment_date to None to prevent default values
    form.appointment_date.data = None
    print(f"Initial form appointment_date.data: {form.appointment_date.data}")
    
    # Check if we have a fallback date from form submission
    fallback_date = None
    if request.method == 'POST' and 'fallback_date' in request.form:
        fallback_date = request.form['fallback_date']
        print(f"Fallback date from form: {fallback_date}")
    
    # Check if user wants to force save despite conflicts
    force_save = request.args.get('force_save') == '1'
    print(f"Force save flag: {force_save}")
    
    # Check if this is an AJAX request
    is_ajax = request.headers.get('X-Requested-With') == 'XMLHttpRequest'
    print(f"Is AJAX request: {is_ajax}")
    
    # Populate the patient select field with all patients
    patients = Patient.query.order_by(Patient.last_name, Patient.first_name).all()
    print(f"Found {len(patients)} patients for dropdown")
    form.patient_id.choices = [(p.id, f"{p.full_name} (MRN: {p.mrn})") for p in patients]
    
    # Initialize form with pre-selected date for GET requests
    if selected_date and request.method == 'GET':
        try:
            # Parse and set the appointment date
            parsed_date = datetime.strptime(selected_date, '%Y-%m-%d').date()
            form.appointment_date.data = parsed_date
            print(f"Set form appointment_date to: {form.appointment_date.data}")
            print(f"Date format check - Selected date: {selected_date}, Parsed as: {parsed_date}, Form value: {form.appointment_date.data}")
        except ValueError:
            # If invalid, set to today's date and show warning
            form.appointment_date.data = datetime.now().date()
            print(f"Invalid date format. Using today's date: {form.appointment_date.data}")
            flash('Invalid date format in URL. Date should be in YYYY-MM-DD format. Using today\'s date instead.', 'warning')
    
    # Handle direct test appointment creation
    if request.args.get('test_create') == '1':
        try:
            # Get first patient for test
            test_patient = patients[0] if patients else None
            if test_patient:
                print(f"TEST MODE: Creating test appointment for patient: {test_patient.full_name}")
                from datetime import time
                # Create test appointment
                test_appointment = Appointment(
                    patient_id=test_patient.id,
                    appointment_date=datetime.now().date(),
                    appointment_time=time(hour=10, minute=30),
                    note="Test appointment"
                )
                db.session.add(test_appointment)
                db.session.commit()
                print(f"TEST MODE: Created appointment with ID: {test_appointment.id}")
                
                # Verify it was created
                verify = Appointment.query.filter_by(id=test_appointment.id).first()
                if verify:
                    print(f"TEST MODE: Successfully verified appointment exists in database")
                    flash(f'Test appointment created successfully with ID: {test_appointment.id}', 'success')
                else:
                    print(f"TEST MODE: Failed to verify appointment in database")
                    flash('Test appointment failed - could not verify creation', 'danger')
                    
                # List all appointments for today
                today_appts = Appointment.query.filter(
                    Appointment.appointment_date == datetime.now().date()
                ).all()
                print(f"TEST MODE: Found {len(today_appts)} appointments for today")
                for appt in today_appts:
                    print(f"TEST MODE: Appointment ID: {appt.id}, Patient: {appt.patient.full_name}, Time: {appt.appointment_time}")
                
                timestamp = int(time_module.time())
                return redirect(url_for('index', refresh=timestamp))
            else:
                flash('No patients available for test appointment creation', 'danger')
        except Exception as e:
            db.session.rollback()
            print(f"TEST MODE ERROR: {str(e)}")
            flash(f'Error in test appointment creation: {str(e)}', 'danger')
            return redirect(url_for('index'))
    
    # Debug form submission
    print(f"Form submitted: {request.method == 'POST'}")
    if request.method == 'POST':
        print(f"Form data: {request.form}")
        print(f"Debug info: {request.form.get('_form_debug', 'none')} - Has errors: {request.form.get('_form_has_errors', 'false')}")
        
        # Create a new form with the POST data but make sure we set the patient choices first
        print(f"POST data before creating form: appointment_date={request.form.get('appointment_date')}")
        form = AppointmentForm(request.form)
        print(f"Form after creation: appointment_date={form.appointment_date.data}")
        
        # Need to set choices before validation
        form.patient_id.choices = [(p.id, f"{p.full_name} (MRN: {p.mrn})") for p in patients]
        
        # Save the appointment date before validation for debugging
        pre_validate_date = form.appointment_date.data
        print(f"Appointment date before validation: {pre_validate_date}, type: {type(pre_validate_date)}")
        
        # Run validation
        validation_result = form.validate()
        print(f"Form validation: {validation_result}")
        
        # Check if the date changed during validation
        post_validate_date = form.appointment_date.data
        print(f"Appointment date after validation: {post_validate_date}, type: {type(post_validate_date)}")
        if not form.validate():
            print(f"Form validation errors: {form.errors}")
            # If in a force save scenario but there's CSRF error, handle special case
            # Modified to handle CSRF errors more gracefully for appointment creation
            # This helps when tokens expire during form interactions
            if 'csrf_token' in form.errors:
                # Recreate the appointment manually instead of relying on form validation
                try:
                    patient_id = request.form.get('patient_id')
                    appointment_date_str = request.form.get('appointment_date')
                    appointment_time_str = request.form.get('appointment_time')
                    note = request.form.get('note', '')
                    
                    # Validate and convert
                    if not patient_id or not appointment_date_str or not appointment_time_str:
                        error_msg = 'Missing required appointment data.'
                        if is_ajax:
                            response = jsonify({'success': False, 'message': error_msg})
                            response.headers['Content-Type'] = 'application/json'
                            return response
                        flash(error_msg, 'danger')
                        return render_template('appointment_form.html', form=form, patients=patients, editing=False)
                    
                    appointment_date = datetime.strptime(appointment_date_str, '%Y-%m-%d').date()
                    time_parts = appointment_time_str.split(':')
                    hour = int(time_parts[0])
                    minute = int(time_parts[1])
                    from datetime import time
                    appointment_time = time(hour=hour, minute=minute)
                    
                    # Create appointment with force save
                    appointment = Appointment(
                        patient_id=int(patient_id),
                        appointment_date=appointment_date,
                        appointment_time=appointment_time,
                        note=note
                    )
                    
                    db.session.add(appointment)
                    db.session.commit()
                    
                    success_msg = 'Appointment added with scheduling conflicts.'
                    timestamp = int(time_module.time())
                    
                    if is_ajax:
                        return jsonify({
                            'success': True, 
                            'message': success_msg,
                            'redirect': f"/date/{appointment_date_str}?refresh={timestamp}"
                        })
                    
                    flash(success_msg, 'warning')
                    return redirect(f"/date/{appointment_date_str}?refresh={timestamp}")
                except Exception as e:
                    db.session.rollback()
                    print(f"Force save error: {str(e)}")
                    error_msg = f'Error creating appointment: {str(e)}'
                    
                    if is_ajax:
                        return jsonify({'success': False, 'message': error_msg})
                    
                    flash(error_msg, 'danger')
    
    # Use a more reliable approach that works with or without form validation
    if request.method == 'POST':
        # Try to create an appointment either way - with form validation or direct data parsing
        print("Processing POST request for appointment creation")
        
        # First, try to get data directly from the form data (more reliable)
        patient_id = request.form.get('patient_id')
        appointment_date_str = request.form.get('appointment_date')
        appointment_time_str = request.form.get('appointment_time') 
        note = request.form.get('note', '')
        
        # Debug info
        print(f"Direct form data: patient_id={patient_id}, date={appointment_date_str}, time={appointment_time_str}")
        print(f"Form validated: {form.validate()}")
        
        # Validate the essential data is present
        if not patient_id or not appointment_date_str or not appointment_time_str:
            error_msg = 'Missing required appointment data.'
            if is_ajax:
                return jsonify({'success': False, 'message': error_msg})
            flash(error_msg, 'danger')
            return render_template('appointment_form.html', form=form, patients=patients, editing=False)
        
        # Convert date and time strings to appropriate objects
        try:
            # Parse the date and time
            appointment_date = datetime.strptime(appointment_date_str, '%Y-%m-%d').date()
            
            # Parse the time string
            time_parts = appointment_time_str.split(':')
            hour = int(time_parts[0])
            minute = int(time_parts[1])
            from datetime import time
            appointment_time = time(hour=hour, minute=minute)
            
            print(f"Successfully parsed date: {appointment_date} and time: {appointment_time}")
        except (ValueError, IndexError) as e:
            print(f"Error parsing date or time: {e}")
            error_msg = 'Invalid date or time format. Please use YYYY-MM-DD for date and HH:MM for time.'
            
            if is_ajax:
                return jsonify({'success': False, 'message': error_msg})
            
            flash(error_msg, 'danger')
            return render_template('appointment_form.html', form=form, patients=patients, editing=False)
        
        print(f"Checking conflicts for date: {appointment_date}, time: {appointment_time}")
        # Check for appointment conflicts
        conflicts = detect_appointment_conflicts(
            date=appointment_date,  # Use the directly parsed date
            time_obj=appointment_time,
            duration_minutes=30  # Default appointment duration
        )
        
        if conflicts and not force_save:
            print(f"Found {len(conflicts)} conflicts and force_save is False")
            # Generate a warning message about the conflict
            conflict_message = format_conflict_message(conflicts)
            warn_msg = f'Warning: {conflict_message}'
            
            if is_ajax:
                return jsonify({
                    'success': False, 
                    'message': warn_msg,
                    'has_conflicts': True,
                    'conflicts': [{'patient': c.patient.full_name, 'time': c.appointment_time.strftime('%I:%M %p')} for c in conflicts]
                })
            
            flash(warn_msg, 'warning')
            # Pass conflicts to template to highlight them
            return render_template('appointment_form.html', 
                                  form=form, 
                                  patients=patients, 
                                  editing=False, 
                                  conflicts=conflicts,
                                  conflict_message=conflict_message)
        
        # Create a new appointment
        try:
            # Get date directly from request.form to avoid WTForms processing
            raw_appointment_date = request.form.get('appointment_date')
            print(f"Raw appointment date: {raw_appointment_date}")
            
            # Use the raw date if possible, or fall back to form data
            if raw_appointment_date:
                try:
                    # Parse the raw date string
                    appointment_date = datetime.strptime(raw_appointment_date, '%Y-%m-%d').date()
                    print(f"Using parsed date: {appointment_date}")
                except ValueError:
                    # Fall back to processed form data
                    appointment_date = form.appointment_date.data
                    print(f"Invalid raw date, using form data: {appointment_date}")
            else:
                # No raw date in form, use processed form data
                appointment_date = form.appointment_date.data
                print(f"No raw date, using form data: {appointment_date}")
            
            # Create the appointment using our directly parsed data
            # Use integer conversion for patient_id to ensure it's the right type
            patient_id_int = int(patient_id)
            print(f"Creating appointment for patient ID: {patient_id_int}, date: {appointment_date}")
            appointment = Appointment(
                patient_id=patient_id_int,
                appointment_date=appointment_date,
                appointment_time=appointment_time,
                note=note
            )
            
            db.session.add(appointment)
            db.session.commit()
            print(f"Appointment created successfully with ID: {appointment.id}")
            
            # Double-check the appointment was actually created and log the result
            verify = Appointment.query.get(appointment.id)
            if verify:
                print(f"Verified appointment exists in database with ID {verify.id}")
                today_count = Appointment.query.filter(
                    Appointment.appointment_date == form.appointment_date.data
                ).count()
                print(f"Total appointments for {form.appointment_date.data}: {today_count}")
            else:
                print("WARNING: Could not verify appointment in database after creation!")
                
            if conflicts and force_save:
                success_msg = 'Appointment added with scheduling conflicts.'
            else:
                success_msg = 'Appointment added successfully.'
            
            # Use our original unparsed date string for the redirect - it's already in the correct format
            appointment_date_str = appointment_date_str  # This is from the form input and is already in 'YYYY-MM-DD' format
            
            # If we have a fallback date from the form, use that instead
            if fallback_date:
                print(f"Using fallback date for redirect: {fallback_date}")
                appointment_date_str = fallback_date
            elif not appointment_date_str:
                # Default to today if still no date
                today = datetime.now().date()
                appointment_date_str = today.strftime('%Y-%m-%d')
                print(f"No appointment date found, defaulting to today: {appointment_date_str}")
                
            # Use a cache-busting parameter to ensure fresh page load
            timestamp = int(time_module.time())
            print(f"Redirecting to index with date_str: {appointment_date_str} and refresh: {timestamp}")
            
            # Construct an absolute URL to ensure proper redirect
            redirect_url = f"/date/{appointment_date_str}?refresh={timestamp}"
            print(f"FINAL REDIRECT URL: {redirect_url}")
            
            # Update flash message to confirm the redirect path for debugging
            success_msg += f" Redirecting to date: {appointment_date_str}"
            
            if is_ajax:
                # Use direct URL path for consistency
                redirect_url = f"/date/{appointment_date_str}?refresh={timestamp}"
                print(f"AJAX Redirect URL: {redirect_url}")
                return jsonify({
                    'success': True, 
                    'message': success_msg,
                    'redirect': redirect_url
                })
            
            if conflicts and force_save:
                flash(success_msg, 'warning')
            else:
                flash(success_msg, 'success')
                
            print(f"Form date: {form.appointment_date.data}, type: {type(form.appointment_date.data)}")
            
            # Use Flask's url_for with external=True to get an absolute URL
            try:
                # First try using url_for with the 'index' route and date parameter
                redirect_url = url_for('index', date=appointment_date_str, refresh=timestamp)
                print(f"URL generated via url_for: {redirect_url}")
            except Exception as url_err:
                print(f"Error with url_for: {str(url_err)}")
                # Fallback to direct URL construction
                redirect_url = f"/date/{appointment_date_str}?refresh={timestamp}"
                print(f"Fallback direct URL: {redirect_url}")
            
            print(f"FINAL REDIRECT: {redirect_url}")
            # Redirect to the date page
            response = redirect(redirect_url)
            print(f"Prepared redirect response: {response}")
            return response
        except Exception as e:
            db.session.rollback()
            print(f"Error saving appointment: {str(e)}")
            error_msg = f'Error saving appointment: {str(e)}'
            
            if is_ajax:
                return jsonify({'success': False, 'message': error_msg})
            
            flash(error_msg, 'danger')
            return render_template('appointment_form.html', form=form, patients=patients, editing=False)
    
    print("-" * 50)
    print(f"FINAL DEBUG - Request method: {request.method}")
    print(f"FINAL DEBUG - Form validation status: {form.validate() if request.method == 'POST' else 'GET request'}")
    print(f"FINAL DEBUG - Selected date: {selected_date}")
    print(f"FINAL DEBUG - Fallback date: {fallback_date}")
    print("-" * 50)
    return render_template('appointment_form.html', form=form, patients=patients, editing=False)


@app.route('/appointments/<int:appointment_id>/edit', methods=['GET', 'POST'])
@fresh_session_operation
def edit_appointment(appointment_id):
    """Edit an existing appointment - Enhanced version with improved data handling"""
    print("=" * 50)
    print(f"Starting edit_appointment function for ID: {appointment_id}")
    print(f"Request method: {request.method}")
    
    # Get the appointment by ID
    appointment = Appointment.query.get_or_404(appointment_id)
    print(f"Found appointment: ID={appointment.id}, Patient={appointment.patient.full_name}, Date={appointment.appointment_date}")
    
    # Create form for display purposes in templates
    form = AppointmentForm(obj=appointment)
    
    # Populate the patient select field with all patients
    patients = Patient.query.order_by(Patient.last_name, Patient.first_name).all()
    form.patient_id.choices = [(p.id, f"{p.full_name} (MRN: {p.mrn})") for p in patients]
    
    # Check if user wants to force save despite conflicts
    force_save = request.args.get('force_save') == '1'
    print(f"Edit appointment - force save: {force_save}")
    
    # Check if this is an AJAX request
    is_ajax = request.headers.get('X-Requested-With') == 'XMLHttpRequest'
    print(f"Edit is AJAX request: {is_ajax}")
    
    # Set the time field for GET request
    if request.method == 'GET':
        form.appointment_time.data = appointment.appointment_time.strftime('%H:%M')
        print(f"Set initial time to: {form.appointment_time.data}")
    
    # Handle POST request (form submission)
    if request.method == 'POST':
        print(f"Edit form data: {request.form}")
        
        # Use direct data parsing approach - get data directly from form data
        patient_id = request.form.get('patient_id')
        appointment_date_str = request.form.get('appointment_date')
        appointment_time_str = request.form.get('appointment_time')
        note = request.form.get('note', '')
        
        print(f"Direct form data: patient_id={patient_id}, date={appointment_date_str}, time={appointment_time_str}")
        
        # Validate essential data is present
        if not patient_id or not appointment_date_str or not appointment_time_str:
            error_msg = 'Missing required appointment data.'
            if is_ajax:
                return jsonify({'success': False, 'message': error_msg})
            flash(error_msg, 'danger')
            return render_template('appointment_form.html', form=form, patients=patients, editing=True, appointment=appointment)
        
        # Parse date and time
        try:
            # Parse the date 
            appointment_date = datetime.strptime(appointment_date_str, '%Y-%m-%d').date()
            
            # Parse the time
            time_parts = appointment_time_str.split(':')
            hour = int(time_parts[0])
            minute = int(time_parts[1])
            from datetime import time
            appointment_time = time(hour=hour, minute=minute)
            
            print(f"Successfully parsed date: {appointment_date} and time: {appointment_time}")
        except (ValueError, IndexError) as e:
            print(f"Error parsing date or time: {e}")
            error_msg = 'Invalid date or time format. Please use YYYY-MM-DD for date and HH:MM for time.'
            
            if is_ajax:
                return jsonify({'success': False, 'message': error_msg})
            
            flash(error_msg, 'danger')
            return render_template('appointment_form.html', form=form, patients=patients, editing=True, appointment=appointment)
        
        # Check for conflicts
        conflicts = detect_appointment_conflicts(
            date=appointment_date,
            time_obj=appointment_time,
            duration_minutes=30,  # Default appointment duration
            appointment_id=appointment.id  # Exclude this appointment from conflict check
        )
        
        if conflicts and not force_save:
            print(f"Found {len(conflicts)} conflicts and force_save is False")
            conflict_message = format_conflict_message(conflicts)
            warn_msg = f'Warning: {conflict_message}'
            
            if is_ajax:
                return jsonify({
                    'success': False, 
                    'message': warn_msg,
                    'has_conflicts': True,
                    'conflicts': [{'patient': c.patient.full_name, 'time': c.appointment_time.strftime('%I:%M %p')} for c in conflicts]
                })
            
            flash(warn_msg, 'warning')
            return render_template('appointment_form.html', 
                                 form=form, 
                                 patients=patients, 
                                 editing=True, 
                                 conflicts=conflicts,
                                 conflict_message=conflict_message,
                                 appointment=appointment)
        
        # Update the appointment with our parsed data
        try:
            # Convert patient_id to integer
            patient_id_int = int(patient_id)
            
            # Update appointment data
            print(f"Updating appointment ID {appointment.id} for patient_id: {patient_id_int}")
            appointment.patient_id = patient_id_int
            appointment.appointment_date = appointment_date
            appointment.appointment_time = appointment_time
            appointment.note = note
            
            # Save changes
            db.session.commit()
            print(f"Appointment updated successfully")
            
            # Set success message
            if conflicts and force_save:
                success_msg = 'Appointment updated with scheduling conflicts.'
            else:
                success_msg = 'Appointment updated successfully.'
            
            # Use a cache-busting timestamp
            timestamp = int(time_module.time())
            
            # Use our parsed date string for the redirect
            appointment_date_str = appointment_date.strftime('%Y-%m-%d')
            
            # Construct redirect URL
            redirect_url = f"/date/{appointment_date_str}?refresh={timestamp}"
            print(f"FINAL EDIT REDIRECT URL: {redirect_url}")
            
            # For AJAX requests
            if is_ajax:
                return jsonify({
                    'success': True, 
                    'message': success_msg,
                    'redirect': redirect_url
                })
            
            # Set flash message
            if conflicts and force_save:
                flash(success_msg, 'warning')
            else:
                flash(success_msg, 'success')
            
            # Redirect to the date page
            return redirect(redirect_url)
        except Exception as e:
            db.session.rollback()
            print(f"Error updating appointment: {str(e)}")
            error_msg = f'Error updating appointment: {str(e)}'
            
            if is_ajax:
                return jsonify({'success': False, 'message': error_msg})
            
            flash(error_msg, 'danger')
            return render_template('appointment_form.html', form=form, patients=patients, editing=True, appointment=appointment)
    
    # For GET requests, just show the form
    return render_template('appointment_form.html', form=form, patients=patients, editing=True, appointment=appointment)

@app.route('/appointments/<int:appointment_id>/delete', methods=['GET', 'POST'])
@fresh_session_operation
def delete_appointment(appointment_id):
    """Delete an appointment and redirect to the home page"""
    print(f"Attempting to delete appointment {appointment_id}")
    
    # Check if this is an AJAX request
    is_ajax = request.headers.get('X-Requested-With') == 'XMLHttpRequest'
    print(f"Delete is AJAX request: {is_ajax}")
    
    try:
        appointment = Appointment.query.get_or_404(appointment_id)
        print(f"Found appointment: {appointment.id} for patient {appointment.patient.full_name}")
        
        # Store the date for redirection
        appointment_date = appointment.appointment_date.strftime('%Y-%m-%d') if appointment.appointment_date else None
        print(f"Appointment date for redirect: {appointment_date}")
        
        # Delete the appointment
        db.session.delete(appointment)
        db.session.commit()
        
        success_msg = 'Appointment deleted successfully.'
        if not is_ajax:
            flash(success_msg, 'success')
        
        # Redirect to the home page, showing the same date with cache-busting
        timestamp = int(time_module.time())
        
        if is_ajax:
            if appointment_date:
                return jsonify({
                    'success': True, 
                    'message': success_msg,
                    'redirect': f"/date/{appointment_date}?refresh={timestamp}"
                })
            else:
                return jsonify({
                    'success': True, 
                    'message': success_msg,
                    'redirect': f"/?refresh={timestamp}"
                })
                
        # Use Flask's url_for for consistency
        try:
            if appointment_date:
                redirect_url = url_for('index', date=appointment_date, refresh=timestamp)
                print(f"Delete redirect URL via url_for: {redirect_url}")
            else:
                redirect_url = url_for('index', refresh=timestamp)
                print(f"Delete redirect URL via url_for (no date): {redirect_url}")
        except Exception as url_err:
            print(f"Error with url_for in delete: {str(url_err)}")
            # Fallback to direct URL construction
            if appointment_date:
                redirect_url = f"/date/{appointment_date}?refresh={timestamp}"
            else:
                redirect_url = f"/?refresh={timestamp}"
                
        print(f"FINAL DELETE REDIRECT: {redirect_url}")
        return redirect(redirect_url)
            
    except Exception as e:
        db.session.rollback()
        error_msg = f'Error deleting appointment: {str(e)}'
        
        if is_ajax:
            return jsonify({'success': False, 'message': error_msg})
        
        flash(error_msg, 'danger')
        
        # Try to redirect to the same date if we have it in the session
        selected_date = request.args.get('date_str')
        timestamp = int(time_module.time())
        
        # Use Flask's url_for for consistency in error case too
        try:
            if selected_date:
                redirect_url = url_for('index', date=selected_date, refresh=timestamp)
            else:
                redirect_url = url_for('index', refresh=timestamp)
        except Exception as url_err:
            print(f"Error with url_for in delete error case: {str(url_err)}")
            # Fallback to direct URL construction
            if selected_date:
                redirect_url = f"/date/{selected_date}?refresh={timestamp}"
            else:
                redirect_url = f"/?refresh={timestamp}"
        
        print(f"FINAL ERROR REDIRECT: {redirect_url}")
        return redirect(redirect_url)
    
@app.route('/patients/<int:patient_id>/conditions/<int:condition_id>/delete', methods=['GET', 'POST'])
def delete_condition(patient_id, condition_id):
    """Delete a medical condition and redirect to the patient detail page"""
    try:
        condition = Condition.query.get_or_404(condition_id)
        
        # Verify this condition belongs to the patient
        if condition.patient_id != patient_id:
            flash('Invalid request: condition does not belong to this patient.', 'danger')
            return redirect(url_for('patient_detail', patient_id=patient_id))
        
        # Delete the condition
        db.session.delete(condition)
        db.session.commit()
        
        flash('Medical condition deleted successfully.', 'success')
        return redirect(url_for('patient_detail', patient_id=patient_id))
            
    except Exception as e:
        db.session.rollback()
        flash(f'Error deleting condition: {str(e)}', 'danger')
        return redirect(url_for('patient_detail', patient_id=patient_id))

@app.route('/patients/<int:patient_id>/vitals/<int:vital_id>/delete', methods=['GET', 'POST'])
def delete_vital(patient_id, vital_id):
    """Delete a vital signs record and redirect to the patient detail page"""
    try:
        vital = Vital.query.get_or_404(vital_id)
        
        # Verify this vital belongs to the patient
        if vital.patient_id != patient_id:
            flash('Invalid request: vital does not belong to this patient.', 'danger')
            return redirect(url_for('patient_detail', patient_id=patient_id))
        
        # Delete the vital
        db.session.delete(vital)
        db.session.commit()
        
        flash('Vital signs record deleted successfully.', 'success')
        return redirect(url_for('patient_detail', patient_id=patient_id))
            
    except Exception as e:
        db.session.rollback()
        flash(f'Error deleting vital signs: {str(e)}', 'danger')
        return redirect(url_for('patient_detail', patient_id=patient_id))

@app.route('/patients/<int:patient_id>/documents/<int:document_id>/delete', methods=['GET', 'POST'])
def delete_document(patient_id, document_id):
    """Delete a medical document and redirect to the patient detail page"""
    try:
        document = MedicalDocument.query.get_or_404(document_id)
        
        # Verify this document belongs to the patient
        if document.patient_id != patient_id:
            flash('Invalid request: document does not belong to this patient.', 'danger')
            return redirect(url_for('patient_detail', patient_id=patient_id))
        
        # Delete the document
        db.session.delete(document)
        db.session.commit()
        
        flash('Document deleted successfully.', 'success')
        return redirect(url_for('patient_detail', patient_id=patient_id))
            
    except Exception as e:
        db.session.rollback()
        flash(f'Error deleting document: {str(e)}', 'danger')
        return redirect(url_for('patient_detail', patient_id=patient_id))

@app.route('/patients/<int:patient_id>/labs/<int:lab_id>/delete', methods=['GET', 'POST'])
def delete_lab(patient_id, lab_id):
    """Delete a lab result and redirect to the patient detail page"""
    try:
        lab = LabResult.query.get_or_404(lab_id)
        
        # Verify this lab belongs to the patient
        if lab.patient_id != patient_id:
            flash('Invalid request: lab result does not belong to this patient.', 'danger')
            return redirect(url_for('patient_detail', patient_id=patient_id))
        
        # Delete the lab
        db.session.delete(lab)
        db.session.commit()
        
        flash('Lab result deleted successfully.', 'success')
        return redirect(url_for('patient_detail', patient_id=patient_id))
            
    except Exception as e:
        db.session.rollback()
        flash(f'Error deleting lab result: {str(e)}', 'danger')
        return redirect(url_for('patient_detail', patient_id=patient_id))

@app.route('/patients/<int:patient_id>/imaging/<int:imaging_id>/delete', methods=['GET', 'POST'])
def delete_imaging(patient_id, imaging_id):
    """Delete an imaging study and redirect to the patient detail page"""
    try:
        imaging = ImagingStudy.query.get_or_404(imaging_id)
        
        # Verify this imaging belongs to the patient
        if imaging.patient_id != patient_id:
            flash('Invalid request: imaging study does not belong to this patient.', 'danger')
            return redirect(url_for('patient_detail', patient_id=patient_id))
        
        # Delete the imaging
        db.session.delete(imaging)
        db.session.commit()
        
        flash('Imaging study deleted successfully.', 'success')
        return redirect(url_for('patient_detail', patient_id=patient_id))
            
    except Exception as e:
        db.session.rollback()
        flash(f'Error deleting imaging study: {str(e)}', 'danger')
        return redirect(url_for('patient_detail', patient_id=patient_id))

@app.route('/patients/<int:patient_id>/consults/<int:consult_id>/delete', methods=['GET', 'POST'])
def delete_consult(patient_id, consult_id):
    """Delete a consult report and redirect to the patient detail page"""
    try:
        consult = ConsultReport.query.get_or_404(consult_id)
        
        # Verify this consult belongs to the patient
        if consult.patient_id != patient_id:
            flash('Invalid request: consult report does not belong to this patient.', 'danger')
            return redirect(url_for('patient_detail', patient_id=patient_id))
        
        # Delete the consult
        db.session.delete(consult)
        db.session.commit()
        
        flash('Consult report deleted successfully.', 'success')
        return redirect(url_for('patient_detail', patient_id=patient_id))
            
    except Exception as e:
        db.session.rollback()
        flash(f'Error deleting consult report: {str(e)}', 'danger')
        return redirect(url_for('patient_detail', patient_id=patient_id))

@app.route('/patients/<int:patient_id>/hospital/<int:hospital_id>/delete', methods=['GET', 'POST'])
def delete_hospital(patient_id, hospital_id):
    """Delete a hospital summary and redirect to the patient detail page"""
    try:
        hospital = HospitalSummary.query.get_or_404(hospital_id)
        
        # Verify this hospital summary belongs to the patient
        if hospital.patient_id != patient_id:
            flash('Invalid request: hospital summary does not belong to this patient.', 'danger')
            return redirect(url_for('patient_detail', patient_id=patient_id))
        
        # Delete the hospital summary
        db.session.delete(hospital)
        db.session.commit()
        
        flash('Hospital summary deleted successfully.', 'success')
        return redirect(url_for('patient_detail', patient_id=patient_id))
            
    except Exception as e:
        db.session.rollback()
        flash(f'Error deleting hospital summary: {str(e)}', 'danger')
        return redirect(url_for('patient_detail', patient_id=patient_id))

@app.route('/patients/<int:patient_id>/screenings/<int:screening_id>/delete', methods=['GET', 'POST'])
def delete_screening(patient_id, screening_id):
    """Delete a screening record and redirect to the patient detail page"""
    try:
        screening = Screening.query.get_or_404(screening_id)
        
        # Verify this screening belongs to the patient
        if screening.patient_id != patient_id:
            flash('Invalid request: screening does not belong to this patient.', 'danger')
            return redirect(url_for('patient_detail', patient_id=patient_id))
        
        # Delete the screening
        db.session.delete(screening)
        db.session.commit()
        
        flash('Screening record deleted successfully.', 'success')
        return redirect(url_for('patient_detail', patient_id=patient_id))
            
    except Exception as e:
        db.session.rollback()
        flash(f'Error deleting screening record: {str(e)}', 'danger')
        return redirect(url_for('patient_detail', patient_id=patient_id))
