"""
Screening Engine - Evaluates patient conditions and triggers appropriate screenings
Based on FHIR Condition resources and user-defined trigger conditions in ScreeningType
"""

from datetime import datetime, timedelta
from typing import List, Dict, Any, Optional, Tuple
import json
import logging
from dataclasses import dataclass

from models import Patient, ScreeningType, Screening, Condition, db
from app import app

# Import shared utilities to eliminate duplicate logic
from shared_screening_utilities import BaseScreeningEngine, ScreeningUtilities

# Set up logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


@dataclass
class ScreeningRecommendation:
    """Represents a screening recommendation generated by the engine"""
    patient_id: int
    screening_type_id: int
    screening_type_name: str
    triggered_by_condition: str
    condition_code: str
    condition_system: str
    priority: str = "Medium"
    due_date: Optional[datetime] = None
    notes: str = ""


class ScreeningEngine(BaseScreeningEngine):
    """
    Main screening engine that evaluates patient conditions and triggers screenings
    """
    
    def __init__(self):
        super().__init__()  # Initialize the base class
        self.app = app
    
    def process_patient_screenings(self, patient_id: int) -> List[Dict[str, Any]]:
        """
        Implementation of abstract method from BaseScreeningEngine
        Generate screening recommendations based on patient conditions
        """
        recommendations = self.evaluate_patient_conditions(patient_id)
        return [
            {
                'patient_id': rec.patient_id,
                'screening_type_id': rec.screening_type_id,
                'screening_type_name': rec.screening_type_name,
                'triggered_by_condition': rec.triggered_by_condition,
                'condition_code': rec.condition_code,
                'priority': rec.priority,
                'due_date': rec.due_date,
                'notes': rec.notes
            } for rec in recommendations
        ]
        
    def evaluate_patient_conditions(self, patient_id: int) -> List[ScreeningRecommendation]:
        """
        Evaluate a patient's conditions and return screening recommendations
        
        Args:
            patient_id: ID of the patient to evaluate
            
        Returns:
            List of screening recommendations
        """
        with self.app.app_context():
            patient = Patient.query.get(patient_id)
            if not patient:
                logger.warning(f"Patient {patient_id} not found")
                return []
            
            # Get patient's active conditions
            conditions = Condition.query.filter_by(
                patient_id=patient_id,
                is_active=True
            ).all()
            
            # Get all active screening types with trigger conditions
            screening_types = ScreeningType.query.filter_by(is_active=True).all()
            screening_types_with_triggers = [
                st for st in screening_types 
                if st.get_trigger_conditions()
            ]
            
            recommendations = []
            
            for condition in conditions:
                matching_screenings = self._find_matching_screenings(
                    condition, screening_types_with_triggers
                )
                
                for screening_type in matching_screenings:
                    # Check if patient already has this screening
                    if not self._patient_already_has_screening(patient_id, screening_type.id):
                        # Check age and gender eligibility
                        if self._is_patient_eligible(patient, screening_type):
                            recommendation = ScreeningRecommendation(
                                patient_id=patient_id,
                                screening_type_id=screening_type.id,
                                screening_type_name=screening_type.name,
                                triggered_by_condition=condition.name,
                                condition_code=condition.code or "Unknown",
                                condition_system="Unknown",  # Simple model doesn't store system
                                priority=self._determine_priority(condition, screening_type),
                                due_date=self._calculate_due_date(screening_type),
                                notes=f"Triggered by condition: {condition.name}"
                            )
                            recommendations.append(recommendation)
            
            return recommendations
    
    def _find_matching_screenings(
        self, 
        condition: Condition, 
        screening_types: List[ScreeningType]
    ) -> List[ScreeningType]:
        """
        Find screening types that match the given condition
        """
        matching_types = []
        
        for screening_type in screening_types:
            trigger_conditions = screening_type.get_trigger_conditions()
            
            for trigger in trigger_conditions:
                if self._condition_matches_trigger(condition, trigger):
                    matching_types.append(screening_type)
                    break  # Avoid duplicates if multiple triggers match
                    
        return matching_types
    
    def _condition_matches_trigger(self, condition: Condition, trigger: Dict[str, str]) -> bool:
        """
        Check if a patient condition matches a screening trigger condition
        """
        # Direct code match
        if condition.code and condition.code == trigger.get('code'):
            # For now, assume code match is sufficient since we don't store system in simple Condition model
            return True
        
        # Fuzzy text matching on condition names
        if condition.name and trigger.get('display'):
            condition_name_lower = condition.name.lower()
            trigger_display_lower = trigger.get('display', '').lower()
            
            # Check if trigger display is contained in condition name or vice versa
            if (trigger_display_lower in condition_name_lower or 
                condition_name_lower in trigger_display_lower):
                return True
        
        return False
    
    def _patient_already_has_screening(self, patient_id: int, screening_type_id: int) -> bool:
        """
        Check if patient already has this type of screening
        """
        screening_type = ScreeningType.query.get(screening_type_id)
        if not screening_type:
            return False
            
        existing_screening = Screening.query.filter_by(
            patient_id=patient_id,
            screening_type=screening_type.name
        ).first()
        
        return existing_screening is not None
    
    def _is_patient_eligible(self, patient: Patient, screening_type: ScreeningType) -> bool:
        """
        Check if patient meets age and gender criteria for screening
        """
        # Check gender eligibility
        if screening_type.gender_specific:
            if patient.sex and patient.sex.lower() != screening_type.gender_specific.lower():
                return False
        
        # Check age eligibility
        if patient.date_of_birth:
            age = (datetime.now().date() - patient.date_of_birth).days // 365
            
            if screening_type.min_age and age < screening_type.min_age:
                return False
                
            if screening_type.max_age and age > screening_type.max_age:
                return False
        
        return True
    
    def _determine_priority(self, condition: Condition, screening_type: ScreeningType) -> str:
        """
        Determine priority based on condition severity and screening importance
        """
        # Default priority logic - can be enhanced based on specific requirements
        priority_keywords = {
            'high': ['diabetes', 'hypertension', 'cancer', 'heart', 'cardiovascular'],
            'low': ['routine', 'preventive', 'maintenance']
        }
        
        condition_name_lower = condition.name.lower() if condition.name else ""
        screening_name_lower = screening_type.name.lower()
        
        for keyword in priority_keywords['high']:
            if keyword in condition_name_lower or keyword in screening_name_lower:
                return "High"
        
        for keyword in priority_keywords['low']:
            if keyword in condition_name_lower or keyword in screening_name_lower:
                return "Low"
        
        return "Medium"
    
    def _calculate_due_date(self, screening_type: ScreeningType) -> datetime:
        """
        Calculate when the screening should be due
        """
        # Default to 30 days from now, but can be customized based on screening frequency
        base_date = datetime.now()
        
        if screening_type.frequency_in_days:
            # For routine screenings, schedule sooner
            days_ahead = min(30, screening_type.frequency_in_days // 4)
        else:
            days_ahead = 30
            
        return base_date + timedelta(days=days_ahead)
    
    def create_screening_recommendations(
        self, 
        recommendations: List[ScreeningRecommendation]
    ) -> List[Screening]:
        """
        Create actual Screening records from recommendations
        """
        created_screenings = []
        
        with self.app.app_context():
            for rec in recommendations:
                try:
                    screening = Screening(
                        patient_id=rec.patient_id,
                        screening_type=rec.screening_type_name,
                        due_date=rec.due_date.date() if rec.due_date else None,
                        frequency="As needed",
                        priority=rec.priority,
                        notes=rec.notes,
                        status="Due"
                    )
                    
                    db.session.add(screening)
                    created_screenings.append(screening)
                    
                    logger.info(
                        f"Created screening recommendation: {rec.screening_type_name} "
                        f"for patient {rec.patient_id} due to {rec.triggered_by_condition}"
                    )
                    
                except Exception as e:
                    logger.error(f"Error creating screening recommendation: {str(e)}")
                    db.session.rollback()
                    continue
            
            try:
                db.session.commit()
                logger.info(f"Successfully created {len(created_screenings)} screening recommendations")
            except Exception as e:
                logger.error(f"Error committing screening recommendations: {str(e)}")
                db.session.rollback()
                created_screenings = []
        
        return created_screenings
    
    def evaluate_all_patients(self) -> Dict[str, Any]:
        """
        Evaluate all patients and generate screening recommendations
        """
        with self.app.app_context():
            patients = Patient.query.all()
            
            total_recommendations = 0
            total_created = 0
            patient_results = {}
            
            for patient in patients:
                try:
                    recommendations = self.evaluate_patient_conditions(patient.id)
                    created_screenings = self.create_screening_recommendations(recommendations)
                    
                    patient_results[patient.id] = {
                        'patient_name': f"{patient.first_name} {patient.last_name}",
                        'recommendations_count': len(recommendations),
                        'created_count': len(created_screenings),
                        'recommendations': [
                            {
                                'screening_type': rec.screening_type_name,
                                'condition': rec.triggered_by_condition,
                                'priority': rec.priority
                            }
                            for rec in recommendations
                        ]
                    }
                    
                    total_recommendations += len(recommendations)
                    total_created += len(created_screenings)
                    
                except Exception as e:
                    logger.error(f"Error evaluating patient {patient.id}: {str(e)}")
                    patient_results[patient.id] = {
                        'patient_name': f"{patient.first_name} {patient.last_name}",
                        'error': str(e)
                    }
            
            return {
                'total_patients_evaluated': len(patients),
                'total_recommendations': total_recommendations,
                'total_created': total_created,
                'patient_results': patient_results
            }


def run_screening_engine_for_patient(patient_id: int) -> Dict[str, Any]:
    """
    Convenience function to run screening engine for a single patient
    """
    engine = ScreeningEngine()
    recommendations = engine.evaluate_patient_conditions(patient_id)
    created_screenings = engine.create_screening_recommendations(recommendations)
    
    return {
        'patient_id': patient_id,
        'recommendations_count': len(recommendations),
        'created_count': len(created_screenings),
        'recommendations': [
            {
                'screening_type': rec.screening_type_name,
                'condition': rec.triggered_by_condition,
                'priority': rec.priority,
                'due_date': rec.due_date.isoformat() if rec.due_date else None
            }
            for rec in recommendations
        ]
    }


def run_screening_engine_for_all_patients() -> Dict[str, Any]:
    """
    Convenience function to run screening engine for all patients
    """
    engine = ScreeningEngine()
    return engine.evaluate_all_patients()